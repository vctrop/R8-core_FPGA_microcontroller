-------------------------------------------------------------------------
-- Design unit: R8 simutation test bench
-- Description: R8 processor connected to a RAM memory
--      The RAM memory is able to load image files generated by the R8 simulator             
-------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;        
use ieee.std_logic_unsigned.ALL;


entity R8_uC is
    port(
        board_clock     : in std_logic;
        board_rst       : in std_logic;
        port_io         : inout std_logic_vector(15 downto 0)
    );
end R8_uC;

architecture structural of R8_uC is
    
      signal clk, clk_mem, clk_div4 : std_logic;
      signal rw, ce, rst, ce_mem, ce_io, ce_portA, rw_n : std_logic;
      signal R8_out, R8_in, addressR8, mem_out, data_portA  : std_logic_vector(15 downto 0);
      alias address_peripherals is addressR8(7 downto 4);
      
begin
    
    PROCESSOR: entity work.R8(behavioral) 
        port map (
            clk         => clk, 
            rst         => rst, 
            data_in     => R8_in, 
            data_out    => R8_out, 
            address     => addressR8, 
            ce          => ce, 
            rw          => rw                                       -- 
        );
    
    
    RAM : entity work.Memory   
        generic map (
            DATA_WIDTH  => 16,       
            ADDR_WIDTH  => 15,         
            IMAGE       => "memory_images/write_portA_BRAM.txt"    
            )
        port map(  
            clk         => clk_mem,
            wr          => rw_n,              -- Write Enable (1: write; 0: read)
            en          => ce_mem,            -- Memory enable
            address     => addressR8(14 downto 0),
            data_in     => R8_out,
            data_out    => mem_out
        );
        
    PORT_A : entity work.BidirectionalPort
        generic map (
            DATA_WIDTH          => 16,
            PORT_DATA_ADDR      => "10",
            PORT_CONFIG_ADDR    => "01",
            PORT_ENABLE_ADDR    => "00" 
        )
        port map(
            clk         => clk,
            rst         => rst, 
            
            -- Processor interface
            data        => data_portA,
            address     => addressR8(1 downto 0),
            wr          => rw_n,                -- 1: write, 0: read
            ce          => ce_portA,
            
            -- External interface
            port_io     => port_io
        );
        
    CLOCK_MANAGER : entity work.ClockManager 
        port map(
          clk_in      => board_clock,
          clk_div2    => clk,
          clk_div4    => clk_div4
         );
         
    RESET_SYNCHRONIZER: entity work.ResetSynchonizer 
        port map(
            clk      => clk,
            rst_in   => board_rst,
            rst_out  => rst
        );
        
    -- Memory access control signals       
    rw_n   <= not rw;    

    data_portA <= R8_out when rw = '0' and ce_portA = '1' else      -- portA data i/o tristate
            (others => 'Z'); 
            
    R8_in <=    data_portA when rw = '1' and ce_portA = '1' else                -- 
                mem_out;

    --memory clock is inverted to work at falling edge borders of the R8 clock
    clk_mem <= not clk;    

    
    -- write enable decoder:
    ce_mem      <= '1' when ce = '1' and addressR8(15) = '0' else '0';
    ce_io       <= '1' when ce = '1' and addressR8(15) = '1' else '0';
    ce_portA    <= '1' when ce_io = '1' and address_peripherals = "0000" else '0';
     
end structural;
