-------------------------------------------------------------------------
-- Design unit: R8 simutation test bench
-- Description: R8 processor connected to a RAM memory
--      The RAM memory is able to load image files generated by the R8 simulator             
-------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;        
use ieee.std_logic_unsigned.ALL;


entity R8_uC is
    port(
        board_clock     : in std_logic;
        board_rst       : in std_logic;
        port_io         : inout std_logic_vector(15 downto 0);
    );
end R8_uC;

architecture structural of R8_uC is
    
      signal clk, clk_mem, clk_div4 : std_logic;
      signal rw, ce, rst, ce_mem, ce_regDisp, rw_n : std_logic;
      signal dataR8, dataBus, addressR8  : std_logic_vector(15 downto 0);
      
begin
    
    PROCESSOR: entity work.R8(behavioral) 
        port map (
            clk         => clk, 
            rst         => rst, 
            data_in     => dataBus, 
            data_out    => dataR8, 
            address     => addressR8, 
            ce          => ce, 
            rw          => rw
        );
    
    
    RAM : entity work.Memory   
        generic map (
            DATA_WIDTH  => 16,       
            ADDR_WIDTH  => 15,         
            IMAGE       => "memory_images/contador_BRAM.txt"    
            )
        port map(  
            clk         => clk_mem,
            wr          => rw_n,              -- Write Enable (1: write; 0: read)
            en          => ce_mem,            -- Memory enable
            address     => addressR8(14 downto 0),
            data_in     => dataR8,
            data_out    => dataBus
        );
        
    PORT_A : entity work.BidirectionalPort
        generic map (
            DATA_WIDTH          => 16,
            PORT_DATA_ADDR      => ,
            PORT_CONFIG_ADDR    => ,
            PORT_ENABLE_ADDR    =>  
        )
        port map(
            clk         => clk,
            rst         => rst, 
            
            -- Processor interface
            data        => ,
            address     => ,
            rw          => ,                -- 0: read; 1: write
            ce          => ,
            
            -- External interface
            port_io     => port_io
        )
        
    CLOCK_MANAGER : entity work.ClockManager 
        port map(
          clk_in      => board_clock,
          clk_div2    => clk,
          clk_div4    => clk_div4
         );
        
         
    RESET_SYNCHRONIZER: entity work.ResetSynchonizer 
        port map(
            clk      => clk,
            rst_in   => board_rst,
            rst_out  => rst
        );
        
    -- Memory access control signals       
    rw_n   <= not rw;    
    --dataBus <= dataR8 when ce = '1' and rw='0' else     -- Writing access
    --        (others => 'Z');    
    --memory clock is inverted to work at falling edge borders of the R8 clock
    clk_mem <= not clk;    

    
    -- write enable decoder:
    ce_mem <= '1' when (ce = '1' and addressR8(15) = '0') else '0';
    ce_regDisp <= '1' when ce = '1' and rw = '0' and addressR8(15) = '1' else '0';
    
end structural;
