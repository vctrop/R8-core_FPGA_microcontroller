-------------------------------------------------------------------------
-- Design unit: R8 simutation test bench
-- Description: R8 processor connected to a RAM memory
--      The RAM memory is able to load image files generated by the R8 simulator             
-------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;        
use ieee.std_logic_unsigned.ALL;


entity R8_BRAM is
    port(
        board_clock     : in std_logic;
        board_rst       : in std_logic;
        display_en_n    : out std_logic_vector(3 downto 0);     --7 segment display interface
        display_data    : out std_logic_vector(7 downto 0)
    );
end R8_BRAM;

architecture behavioral of R8_BRAM is
    
      signal clk, clk_mem, clk_div4 : std_logic;
      signal rw, ce, rst, ce_mem, ce_regDisp, rw_n : std_logic;
      signal dataR8, dataBus, addressR8  : std_logic_vector(15 downto 0);    
      signal regDisp    : std_logic_vector(15 downto 0);
      alias  num0   : std_logic_vector is regDisp(3 downto 0);
      alias  num1   : std_logic_vector is regDisp(7 downto 4);
      alias  num2   : std_logic_vector is regDisp(11 downto 8);
      alias  num3   : std_logic_vector is regDisp(15 downto 12);                  
      signal display0, display1, display2, display3 : std_logic_vector(7 downto 0);
begin
    
    PROCESSOR: entity work.R8(behavioral) 
        port map (
            clk         => clk, 
            rst         => rst, 
            data_in     => dataBus, 
            data_out    => dataR8, 
            address     => addressR8, 
            ce          => ce, 
            rw          => rw
        );
    
    
    RAM : entity work.Memory   
        generic map (
            DATA_WIDTH  => 16,       
            ADDR_WIDTH  => 15,         
            IMAGE       => "memory_images/Todas_Instrucoes_R8.txt"    
            )
        port map(  
            clk         => clk_mem,
            wr          => rw_n,              -- Write Enable (1: write; 0: read)
            en          => ce_mem,            -- Memory enable
            address     => addressR8(14 downto 0),
            data_in     => dataR8,
            data_out    => dataBus
        );
        
        
    CLOCK_MANAGER : entity work.ClockManager 
        port map(
          clk_in      => board_clock,
          clk_div2    => clk,
          clk_div4    => clk_div4
         );
        
         
    RESET_SYNCHRONIZER: entity work.ResetSynchonizer 
        port map(
            clk      => clk,
            rst_in   => board_rst,
            rst_out  => rst
        );
        
    
    REG_DISP: process(clk, rst)
    begin
        if rst = '1' then
            regDisp <= (others => '0');
            
        elsif (rising_edge(clk) and ce_regDisp = '1') then
            regDisp <= dataR8;
        end if;
    end process;
    
    DISPLAY_CONTROL: entity work.DisplayCtrl 
        port map(
            clk             => clk,
            rst             => rst,
            segments        => display_data,
            display_en_n    => display_en_n,
            display0        => display0,  -- Right most display
            display1        => display1,
            display2        => display2,
            display3        => display3   -- Left most display
        );
    
    
    -- 7 segment decoders
    DECODER0: entity work.SegmentDecoder
        port map(
            digit  => num0,
            segment => display0
        );

    DECODER1: entity work.SegmentDecoder
        port map(
            digit  => num1,
            segment => display1
        );
        
    DECODER2: entity work.SegmentDecoder
        port map(
            digit  => num2,
            segment => display2
        );
    
    DECODER3: entity work.SegmentDecoder
        port map(
            digit  => num3,
            segment => display3
        );
        
        
    -- Memory access control signals       
    rw_n   <= not rw;    
    dataBus <= dataR8 when ce = '1' and rw='0' else     -- Writing access
            (others => 'Z');    
    --memory clock is inverted to work at falling edge borders of the R8 clock
    clk_mem <= not clk;    

    
    -- write enable decoder:
    ce_mem <= '1' when (ce = '1' and addressR8(15) = '0') else '0';
    ce_regDisp <= '1' when ce = '1' and rw = '0' and addressR8(15) = '1' else '0';
    
end behavioral;
